import tkinter as tk
import tkinter.ttk as ttk
import datetime as da
import calendar as ca
import pymysql.cursors

WEEK = ['日', '月', '火', '水', '木', '金', '土']
WEEK_COLOUR = ['red', 'black', 'black', 'black','black', 'black', 'blue']
actions = ('学校','試験', '課題', '行事', '就活', 'アルバイト','旅行')

class YicDiary:
  def __init__(self, root):
    root.title('予定管理アプリ')
    root.geometry('520x280')
    root.resizable(0, 0)
    root.grid_columnconfigure((0, 1), weight=1)
    self.sub_win = None

    self.year  = da.date.today().year
    self.mon = da.date.today().month
    self.today = da.date.today().day

    self.title = None
    # 左側のカレンダー部分
    leftFrame = tk.Frame(root)
    leftFrame.grid(row=0, column=0)
    self.leftBuild(leftFrame)

    # 右側の予定管理部分
    rightFrame = tk.Frame(root)
    rightFrame.grid(row=0, column=1)
    self.rightBuild(rightFrame)

    self.var = tk.StringVar()


  #-----------------------------------------------------------------
  # アプリの左側の領域を作成する
  #
  # leftFrame: 左側のフレーム
  def leftBuild(self, leftFrame):
    self.viewLabel = tk.Label(leftFrame, font=('', 10))
    beforButton = tk.Button(leftFrame, text='＜', font=('', 10), command=lambda:self.disp(-1))
    nextButton = tk.Button(leftFrame, text='＞', font=('', 10), command=lambda:self.disp(1))

    self.viewLabel.grid(row=0, column=1, pady=10, padx=10)
    beforButton.grid(row=0, column=0, pady=10, padx=10)
    nextButton.grid(row=0, column=2, pady=10, padx=10)

    self.calendar = tk.Frame(leftFrame)
    self.calendar.grid(row=1, column=0, columnspan=3)
    self.disp(0)


  #-----------------------------------------------------------------
  # アプリの右側の領域を作成する
  #
  # rightFrame: 右側のフレーム
  def rightBuild(self, rightFrame):
    r1_frame = tk.Frame(rightFrame)
    r1_frame.grid(row=0, column=0, pady=10)

    temp = '{}年{}月{}日の予定'.format(self.year, self.mon, self.today)
    self.title = tk.Label(r1_frame, text=temp, font=('', 12))
    self.title.grid(row=0, column=0, padx=20)

    button = tk.Button(rightFrame, text='追加', command=lambda:self.add())
    button.grid(row=0, column=1)

    self.r2_frame = tk.Frame(rightFrame)
    self.r2_frame.grid(row=1, column=0)

    self.schedule()


  #-----------------------------------------------------------------
  # アプリの右側の領域に予定を表示する
  #
  def schedule(self):
    # ウィジットを廃棄
    for widget in self.r2_frame.winfo_children():
      widget.destroy()

    # データベースに予定の問い合わせを行う
    pass
    

  #-----------------------------------------------------------------
  # カレンダーを表示する
  #
  # argv: -1 = 前月
  #        0 = 今月（起動時のみ）
  #        1 = 次月
  def disp(self, argv):
    self.mon = self.mon + argv
    if self.mon < 1:
      self.mon, self.year = 12, self.year - 1
    elif self.mon > 12:
      self.mon, self.year = 1, self.year + 1

    self.viewLabel['text'] = '{}年{}月'.format(self.year, self.mon)

    cal = ca.Calendar(firstweekday=6)
    cal = cal.monthdayscalendar(self.year, self.mon)

    # ウィジットを廃棄
    for widget in self.calendar.winfo_children():
      widget.destroy()

    # 見出し行
    r = 0
    for i, x in enumerate(WEEK):
      label_day = tk.Label(self.calendar, text=x, font=('', 10), width=3, fg=WEEK_COLOUR[i])
      label_day.grid(row=r, column=i, pady=1)

    # カレンダー本体
    r = 1
    for week in cal:
      for i, day in enumerate(week):
        if day == 0: day = ' ' 
        label_day = tk.Label(self.calendar, text=day, font=('', 10), fg=WEEK_COLOUR[i], borderwidth=1)
        if (da.date.today().year, da.date.today().month, da.date.today().day) == (self.year, self.mon, day):
          label_day['relief'] = 'solid'
        label_day.bind('<Button-1>', self.click)
        label_day.grid(row=r, column=i, padx=2, pady=1)
      r = r + 1

    # 画面右側の表示を変更
    if self.title is not None:
      self.today = 1
      self.title['text'] = '{}年{}月{}日の予定'.format(self.year, self.mon, self.today)


  #-----------------------------------------------------------------
  # 予定を追加したときに呼び出されるメソッド
  #
  def add(self):
    if self.sub_win == None or not self.sub_win.winfo_exists():
      self.sub_win = tk.Toplevel()
      self.sub_win.geometry("300x300")
      self.sub_win.resizable(0, 0)

      # ラベル
      sb1_frame = tk.Frame(self.sub_win)
      sb1_frame.grid(row=0, column=0)
      temp = '{}年{}月{}日　追加する予定'.format(self.year, self.mon, self.today)
      title = tk.Label(sb1_frame, text=temp, font=('', 12))
      title.grid(row=0, column=0)

      # 予定種別（コンボボックス）
      sb2_frame = tk.Frame(self.sub_win)
      sb2_frame.grid(row=1, column=0)
      label_1 = tk.Label(sb2_frame, text='種別 : 　', font=('', 10))
      label_1.grid(row=0, column=0, sticky=tk.W)
      self.combo = ttk.Combobox(sb2_frame, state='readonly', values=actions)
      self.combo.current(0)
      self.combo.grid(row=0, column=1)

      # テキストエリア（垂直スクロール付）
      sb3_frame = tk.Frame(self.sub_win)
      sb3_frame.grid(row=2, column=0)
      self.text = tk.Text(sb3_frame, width=40, height=15)
      self.text.grid(row=0, column=0)
      scroll_v = tk.Scrollbar(sb3_frame, orient=tk.VERTICAL, command=self.text.yview)
      scroll_v.grid(row=0, column=1, sticky=tk.N+tk.S)
      self.text["yscrollcommand"] = scroll_v.set

      # 保存ボタン
      sb4_frame = tk.Frame(self.sub_win)
      sb4_frame.grid(row=3, column=0, sticky=tk.NE)
      button = tk.Button(sb4_frame, text='保存', command=lambda:self.done())
      button.pack(padx=10, pady=10)
    elif self.sub_win != None and self.sub_win.winfo_exists():
      self.sub_win.lift()


  #-----------------------------------------------------------------
  # 予定追加ウィンドウで「保存」を押したときに呼び出されるメソッド
  #
  def done(self):
    date = f'{self.year}-{self.mon}-{self.today}'
    print(date)
    category = self.combo.get()
    print(category)
    contents = self.text.get("1.0", "end")
    print(contents)
    
    # データベースに新規予定を挿入する
    host = '127.0.0.1'
    user = 'root'
    password = ''
    db = 'app01'
    charset = 'utf8mb4'
    connection = pymysql.connect(host=host,
                             user=user,
                             password=password,
                             db=db,
                             charset=charset,
                             cursorclass=pymysql.cursors.DictCursor)
    try:
        connection.begin()

        with connection.cursor() as cursor:    # cursor = connection.cursor() と書くこともある...(データベースからcorsorを一度取り出す→直接データベースとはやり取りしない)
            sql1 = "insert into calendar values('{}')".format(date)
            sql2 = "insert into schedule values('{}', '{}', '{}')".format(date, category, contents)
            cursor.execute(sql1)
            cursor.execute(sql2)             
        connection.commit()

    except Exception as e:
      print('ERROR:', e)
      connection.rollback()

    finally:
        connection.close()

    self.sub_win.destroy()


  #-----------------------------------------------------------------
  # 日付をクリックした際に呼びだされるメソッド（コールバック関数）
  #
  # event: 左クリックイベント <Button-1>
  def click(self, event):
    day = event.widget['text']
    if day != ' ':
      self.title['text'] = '{}年{}月{}日の予定'.format(self.year, self.mon, day)
      self.today = day

    host = '127.0.0.1'
    user = 'root'
    password = ''
    db = 'app01'
    charset = 'utf8mb4'
    connection = pymysql.connect(host=host,
                             user=user,
                             password=password,
                             db=db,
                             charset=charset,
                             cursorclass=pymysql.cursors.DictCursor)

    try:
        connection.begin()

        with connection.cursor() as cursor:
            sql1 = "select * from schedule join root on root.date where root.date='{}-{}-{}';".format(self.year, self.mon, day)
            cursor.execute(sql1)
#            result = cursor.fetcall()

            # ウェジットの削除
            for widget in self.r2_frame.winfo_children():
              widget.destroy()
              
            for dict in cursor:
              for key, value in dict.items():
                if key == 'last_name' or key == 'category' or key == 'contents':
                  label = ttk.Label(self.r2_frame, text=value)
                  label.pack()

        connection.commit()

    except Exception as e:
      print('ERROR:', e)
      connection.rollback()

    finally:
        connection.close()


class Login:
  def __init__(self, sub_root):
    sub_root.title('ログインページ')
    self.frame1 = ttk.Frame(sub_root, padding=(32))
#    sub_root.protocol('WM_DELETE_WINDOW', (lambda: 'pass')())
    self.frame1.grid()

    label1 = ttk.Label(self.frame1, text='名前', padding=(10, 2))
    label1.grid(row=0, column=0, sticky=tk.E)

    self.name = tk.StringVar()
    self.name_entry = ttk.Entry(self.frame1, textvariable=self.name, width=30)
    self.name_entry.grid(row=0, column=1)

    label2 = ttk.Label(self.frame1, text='パスワード', padding=(10, 2))
    label2.grid(row=1, column=0, sticky=tk.E)

    self.password = tk.StringVar()
    self.password_entry = ttk.Entry(self.frame1, textvariable=self.password, width=30, show='*')
    self.password_entry.grid(row=1, column=1)

    buttton1 = ttk.Button(self.frame1, text='ログイン', command=lambda:self.try_login(sub_root))
    buttton1.grid(row=2, column=1, columnspan=2, sticky=tk.E)
    
    button2 = ttk.Button(self.frame1, text='新規登録はこちら', command=lambda:self.register(sub_root))
    button2.grid(row=4, column=1, sticky=tk.E)

    label3 = ttk.Label(self.frame1, text='名前とパスワードを入力して下さい', padding=(5, 2))
    label3.grid(row=3, column=0, columnspan=2, sticky=tk.E)

  # ログイン
  def try_login(self, sub_root):
    host = '127.0.0.1'
    user = 'root'
    pssword = ''
    db = 'app01'
    charset = 'utf8mb4'
    connection = pymysql.connect(host=host,
                              user=user,
                              password='',
                              db=db,
                              charset=charset,
                              cursorclass=pymysql.cursors.DictCursor)

    try:

        # データが存在するか検証
        with connection.cursor() as cursor:
          sql1 = "SELECT * FROM family WHERE last_name='{}' AND password='{}';".format(self.name_entry.get(), self.password_entry.get())
          cursor.execute(sql1)
        
          # 認証処理
          if len(cursor.fetchall()) != 0:
            sub_root.destroy()
          else:
            pass

    except Exception as e:
      print('ERROR:', e)
      connection.rollback()

    finally:
        connection.close()

  # 新規登録
  def register(self, sub_root):
    sub_win = tk.Toplevel()
    sub_win.title('新規登録')
    sub_win.geometry('400x200')

    first_name_label = ttk.Label(sub_win, text='苗字', padding=(10, 2))
    first_name_label.place(x=10, y=30)
    first_name = tk.StringVar()
    first_name_entry = ttk.Entry(sub_win, textvariable=first_name, width=30)
    first_name_entry.place(x=70, y=30)

    last_name_label = ttk.Label(sub_win, text='名前', padding=(10, 2))
    last_name_label.place(x=10, y=60)
    last_name = tk.StringVar()
    last_name_entry = ttk.Entry(sub_win, textvariable=last_name, width=30)
    last_name_entry.place(x=70, y=60)
   
    birth_label1 = ttk.Label(sub_win, text='生年月日')
    birth_label1.place(x=10, y=90)
    birth_year = tk.StringVar()
    birth_year_entry = ttk.Entry(sub_win, textvariable=birth_year, width=10)
    birth_year_entry.place(x=70, y=90)
    birth_label2 = ttk.Label(sub_win, text='年')
    birth_label2.place(x=130, y=90)

    birth_label3 = ttk.Label(sub_win, text='月')
    birth_label3.place(x=220, y=90)
    birth_mon = tk.StringVar()
    birth_mon_entry = ttk.Entry(sub_win, textvariable=birth_mon, width=10)
    birth_mon_entry.place(x=150, y=90)

    birth_label4 = ttk.Label(sub_win, text='日')
    birth_label4.place(x=310, y=90)
    birth_day = tk.StringVar()
    birth_day_entry = ttk.Entry(sub_win, textvariable=birth_day, width=10)
    birth_day_entry.place(x=240, y=90)

    relation_label = ttk.Label(sub_win, text='家族関係', padding=(10, 2))
    relation_label.place(x=5, y=120)
    relate = tk.StringVar()
    relate_entry = ttk.Entry(sub_win, textvariable=relate)
    relate_entry.place(x=70, y=120)

    password_label = ttk.Label(sub_win, text='パスワード', padding=(10, 2))
    password_label.place(x=10, y=150)
    password = tk.StringVar()
    relate_entry = ttk.Entry(sub_win, textvariable=password)
    relate_entry.place(x=70, y=150)




def Main():
  
  sub_root = tk.Tk()
  Login(sub_root)
  sub_root.mainloop()

  root = tk.Tk()
  YicDiary(root)
  root.mainloop()

if __name__ == '__main__':
  Main()
